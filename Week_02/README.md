# 学习笔记

切题四件套（覃超老师）：

- 题目先理解清楚
- 先把所有解法都在脑海过一遍
- 写代码
- 测试样例

五毒神掌（覃超老师）：

- 第一遍：五分钟读题思考，有思路就直接写，没思路就直接看题解并默写题解
- 第二遍：不看题解，自己写代码
- 第三遍：24小时后
- 第四遍：一周后
- 第五遍：面试前

学习方法建议和误区（自己总结的）：

- 不要在同一道题上一直研究，就像同一个汉字看多了就会不认识，同一道题一直研究“神经会疲劳”，这时候要换换题目换换脑子，过几个小时再来研究
- 不要追求完美主义，做笔记不要把所有解法都记下来，只记自己目前领悟最深的就行
- 好记性不如烂笔头，烂笔头不如谷歌；与其辛苦做所谓的大而全的笔记，不如多逛逛力扣国际站、多用谷歌搜别人的笔记总结

## week1刷题遍数记录
课内实战
| 敲代码 | 阅读别人代码 | 解法          | 题目                                                         |
| ---- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 2    |     | 暴力、双指针  | [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/) |
| 2    |     |               | [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) |
| 2    | 1   |               | [15. 三数之和](https://leetcode-cn.com/problems/3sum/)       |
| 2    | 1   |                  | [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |
| 2    | 1   | 递归、迭代       | [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) |
| 2    | 1   | 哈希表、快慢指针 | [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/) |
| 1    | \*2 | 哈希表、\*快慢指针 | [\*142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) |
| 1    | \*1 |                  | [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) |
| 2    | 2   |      | [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) |
| 2    |     |      | [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)   |
| 1    | \*3 |      | [\*84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) |
| 1    | 2   |      | [\*239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/) |

课后作业
| 敲代码 | 阅读别人代码 | 解法                 | 题目                                                         |
| ------ | ------------ | -------------------- | ------------------------------------------------------------ |
| 2      |              |                      | [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/) |
| 1      |              |                      | [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/) |
| 1      |              |                      | [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) |
| 1      | 1            | 就地合并、开额外空间 | [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) |
| 1      |              |               | [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)     |
| 2      | 1            | 末尾补0、交换 | [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/) |
| 1      |              |  | [66. 加一](https://leetcode-cn.com/problems/plus-one/) |
| 1      |              |  | [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/) |
|        |              | | [641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/) |
| 1      | \*1 | | [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/) |
| 1      |  | | [\*42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) |

课外刷题

| 敲代码 | 阅读别人代码 | 解法                       | 题目                                                         |
| ------ | ------------ | -------------------------- | ------------------------------------------------------------ |
| 1      | 1            | DP、DP状压                 | [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/) |
| \*0    |              | 构造图、广搜、两边同时广搜 | [\*127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/) |
| 1      |              | split库函数                | [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/) |

## week2刷题遍数记录
课内实战
| 敲代码 | 阅读别人代码 | 备注    | 题目                                                         |
| ---- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1 | \*1 | 多复习题解 | [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) |
| 这题重复 | - | - | 239. 滑动窗口最大值 |
| 这题重复 | - | - | 70. 爬楼梯 |
| 1 | 1 | 多复习 | [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/) |
| 1 |  | 软柿子 | [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) |
| 1 |  | 软柿子 | [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |
| 1 | 1 | 多复习 | [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) |
| 1 | 1 | 有点意思 | [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) |

课后作业
| 敲代码 | 阅读别人代码 | 备注               | 题目                                                         |
| ------ | ------------ | -------------------- | ------------------------------------------------------------ |
| 1 |    |      | [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) |
| 1 | | | [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) |
| 1 | | 递归、迭代 | [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) |
| 1 | | 递归、迭代 | [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) |
| 1 | |  | [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) |
| 1 | 2 | 堆、3指针DP | [\*剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)、[\*264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/) |
| 1 | | | [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/) |
| 1 | 2 | | [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) |
| 1 | 1 | | [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |
| 1 | | | [77. 组合](https://leetcode-cn.com/problems/combinations/) |
| 1 | | | [46. 全排列](https://leetcode-cn.com/problems/permutations/) |
| 1 | | | [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) |

课外刷题

| 敲代码 | 阅读别人代码 | 解法                       | 题目                                                         |
| ------ | ------------ | -------------------------- | ------------------------------------------------------------ |
| 1 |    |      | [1021. 删除最外层的括号](https://leetcode-cn.com/problems/remove-outermost-parentheses/) |
| 1 | | | [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) |
| 1 | 1 | | [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/) |

## 刷题总结
### 二叉树遍历
[先序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)由于是尾递归，所以很容易改成迭代。
[中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)改迭代比较难，主要方法有颜色标记法、左臂下探法。
[后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)改迭代更难。

二叉树遍历改迭代感觉没啥意义，有精力还不如先练其它题目。

### 层次遍历

传统的层次遍历不能将不同层的节点“分隔”开来，代码上可以用一个小技巧“分隔”。

层次遍历分隔不同层的小技巧见[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)，这个技巧掌握后是非常实用的。

### 丑数

这题练习的重点在于：用堆解法后如何分析出时空复杂度？

### TopK问题

找TopK的方法如下。

- 最正统的方法是用堆
- 也可以用sort偷懒解决
- 甚至可以用快排的思想，适合练手帮助理解快排，实际意义不大，见[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)的题解

K是什么？

- K可以是整数，这最简单了，见[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
- K可以是出现的频率，见[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)、[692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)，可以构造`(freq, num)`的复合结构进行堆排序，这就需要内置的堆支持传入比较器了（各个语言有各自的办法）

- K可以是其它东西，见[658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)、[973. 最接近原点的 K 个点](https://leetcode-cn.com/problems/k-closest-points-to-origin/)

#### K是整数

又分为大顶堆、小顶堆来解决，可以直接用内置的堆/优先级队列。

像Python不支持大顶堆怎么办呢？

方法一：取负数把大顶堆问题变小顶堆问题（妙啊！开拓思维）

方法二：建立小顶堆后弹出N - K个元素，剩下K个就是了（妙啊！开拓思维）

方法三：谷歌搜「Python max heap」，其实Python也有办法支持大顶堆的

#### K是自定义结构

对于系统不认识的类型，还想要调用系统自带的函数，API风格有：

- Python要传入key函数用于提取出可比较的key
- Java要传入Comparator用于比较两个元素的大小

Python代码示例：

```python
from heapq import nlargest
arr = [(1, 'aa'), (5, 'bb'), (2, 'cc')]
tmp = nlargest(2, arr, key=operator.itemgetter(0))
sorted_arr = [word for _, word in tmp]  # ['bb', 'cc']
```

Java代码示例：略。

对比来说，Python这种风格看起来很优雅，但适用面不广，比如[658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)这题Python用堆来做就很难提取出key。

### 二叉树最近公共祖先

注意[这题](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)节点只有left、right指针，没有parent指针。

题目特性：

- 根节点一定是解，但不是最优解
- 最优解存在且唯一
- 必须掌握左右孩子信息后才能对当前节点做出决策，因此要用后序遍历

#### 后序遍历

采用后序遍历会先遇到最优解，后遇到次优解，所以找到第一个解就可以停下来了。递归（不像迭代）是停不下来的，因此我们要避免次优解覆盖最优解的可能。

递归程序避免覆盖最优解的几个技巧：

- 代码逻辑本身保证不会覆盖，见官方题解
- 用全局变量保存解，判断是否已经被赋值了
- 递归中子函数通过返回值告知父函数是否已经找到解，若找到，父函数直接返回子函数的解即可，是一种将最优解层层上报的感觉

```python
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        if not root or root == p or root == q: return root

        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left:
            return right
        elif not right:
            return left
        else:
            return root
```

#### 存储父节点信息

对于动态类型语言（如Python），可以直接在原来的结构上增加parent字段。对于静态类型语言（如C++、Java）可以单独开一个Map记录节点和其父节点的映射。

代码，略。

## 代码模板

todo: 现在是Python语言的模板，考虑也弄些别的语言的模板？

### 树

DFS

```python
def dfs(node):
  if not node: return
  # ... node
  if node.left: dfs(node.left)
  if node.right: dfs(node.right)
```

BFS

```python
def bfs(node):
	queue = collections.deque()
  if node: queue.append(node)
  while queue:
    cur = queue.popleft()
    # ... cur
    if cur.left: queue.append(cur.left)
    if cur.right: queue.append(cur.right)
```

层次遍历 (带有层级信息)

```python

```

先序遍历、中序遍历、后序遍历，略。

### 图

DFS

```python
visited = set()
def dfs(node):
  if node in visited: return
  visited.add(node)
  process(node)  # 根据业务替换
  for child in node.children:
		if child not in visited:
      dfs(child)
```

BFS will_visit

```python
def bfs(graph, start):
    queue = collections.deque()
    if start: queue.append(start)
    will_visit = { start, }
    while queue:
        node = queue.popleft()
        process(node)  # 根据业务替换
        for neighbor in gen_neighbors(node):  # 根据业务替换
        if neighbor not in will_visit:
            queue.append(neighbor)
            will_visit.add(neighbor)
```

BFS visited，因为 visited 比 will_visit 更新更迟钝，所以等 queue.pop 的时候才会发现重复，会浪费 queue 更多空间

```python
def bfs(graph, start):
    queue = collections.deque()
    if start: queue.append(start)
    visited = set()
    while queue:
        node = queue.popleft()
        if node in visited: continue  # 跳过重复节点
        visited.add(node)
        process(node)
        for neighbor in gen_neighbors(node):
        queue.append(neighbor)  # 会推入重复节点，浪费队列空间
```

BFS will_visit，按层遍历

```python
def bfs(graph, start):
    queue = collections.deque()
    if start: queue.append(start)
    will_visit = { start, }
    while queue:
        n = len(queue)
        while n:
        n -= 1
        node = queue.popleft()
        process(node)  # 根据业务替换
        for neighbor in gen_neighbors(node):  # 根据业务替换
            if neighbor not in will_visit:
            queue.append(neighbor)
            will_visit.add(neighbor)
```
